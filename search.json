[{"body":"struct Section–> This is like the section of a page and is made up of one or multiple  \\ lines . Fields: line–> String which makes up a section Section(line)–> Helper function to call the constructor of the type Section line(section::Section)–> Getter for accessing the underlying field  \\ line . Page–> The type that represents a page in a document . Fields: sections–> Array of Section type . name–> Name of the module being documented . Page–> Helper function to create constructer for Page type . sections–> Getter for accessing teh underlying field  \\ sections \\  of Page . name–> Getter for accessing teh underlying field ame \\  of Page . img(img _ path::String)–> Helper function to load images within a notebook .  This can be helpful to have images appear in the final document . stitchCode(cell::Cell)–> Stitches the code in a Pluto notebook cell with the output of that code .  The output is acode block . stitchCode(cellop::AbstractString)–> Removes the quotes from a string and creates a code block with that string inside the newely formed code block stitchCode(cellop::AbstractString)–> When supplied with a FunctionDocs type, stitchCode appends together the object docstrings and generates documentation for that particular object struct FunctionDocs–> Stores the document of different objects . funcDocs–> Array of strings . FunctionDocs(funcDocs)–> Helper for accessing the FunctionDocs constructer . collectFuncDocs(obj)–> Collects objects (functions, methods, macro structs etc . ) and creates an array of documents (generated from teh docstrings) .  Creates aFunctionDocs type from these documents . showDoc(o)–> Takes an object and builds markdown documentation . CreatePage–> Creates the  \\ Page \\  type from the markdown and example code cells of the supplied notebook .  The filename is the name of the notebook which is parsed . “ This is a test \\ n ” save _ page(io, page::Page)–> Take the contents from a  \\ Page \\  type and write to the io save page(save page(io, docnames::Array { String,1}))–> Given an array of document names, creates a table of content save page(save page(io, docnames::Array { String,1}))–> Given an array of document names, creates a table of content save _ page(page::Page, path::String)–> Given a  \\ Page \\  type and the required path, creates the related markdwon file in the specified path .  The name of the resulting markdown file is same as the nameof the notebook for which the document is generated save _ page(page::Page, path::String)–> Given a  \\ Page \\  type and the required path, creates the related markdwon file in the specified path .  The name of the resulting markdown file is same as the nameof the notebook for which the document is generated save _ page(docnames::Array { String,1})–> Given an array of documents, creates the related table of contents in  \\ toc . md \\ export2html(file::String, path::String)–> Generate document for a file in the given path export2html(files::AbstractVector, path::String)–> Map the  export2html(file, path)  to a given vector of file . export2html(files::AbstractVector, path::String)–> Map the  export2html(file, path)  to a given vector of file . export2html()–> Higher level API to generate documents for all the valid notebooks createtoc()–> Create the tableof contents and save that in toc . md inside docs directory","id":"docs\\Documenter.html"},{"body":"nbdev . jl This is an attempt to port fastai nbdev to julia . ☠️ Currently under heavy development and I am introducing breaking changes almost daily .","id":"README.html#nbdevjl"}]